# `awk`, `sed` and `paste` তে  টেক্সট পার্সিং

 - **লেখক** : Kathi Unglert
 - **গবেষণা ক্ষেত্র** : আগ্নেয় ভূপদার্থবিদ্যা  
 - **পঠনের বিষয়** :  লাজুক আবরনির `awk`, `sed` এবং `paste` পরিচিতি । 
 - **অনুবাদক**  : [Bolaram Paul](https://github.com/bolaram)

## `awk`

চেক কর তুমি  `awk` ইন্সটল করেছ কিনা  `which` কমান্ড  দ্বারা :

```
$: which awk
```

তুমি এরকম কিছু পাবে :

```
/usr/bin/awk
```

যদি তোমার  `awk` ইন্সটল করা না থাকে তাহলে  [এখানে](http://linux.softpedia.com/get/Text-Editing-Processing/Filters/GNU-awk-207.shtml) পেতে পার ।


`volcano_observations.dat` আছে নিচের লাইনগুলতে 
(`cat volcano_observations.dat` দ্বারা দেখার চেস্টা কর ):

```
month level observation
april 1 steam
may 2 ash
june 4 plinian
july 1 steam
august 2 earthquakes
september 3 subplinian
october 2 earthquakes
november 1 steam
```

আমরা  `cat` দ্বারা সমান ফলাফল পেতে পারি :

```
awk '{print $0}' volcano_observations.dat
```

  - **প্রতিযোগিতামুলক প্রশ্ন **:  কিভাবে প্রিন্ট ফাইলের আউটপুট পাওআ জায়  ?
  - **সমাধান **: `awk '{print $0}' volcano_observations.dat > observations2.dat`


নিচের মত প্রিন্ট করতে আমরা নির্দিষ্ট কলাম ব্যবহার করতে পারি :

```
awk '{print $3}' volcano_observations.dat
```

কিন্তু , আমরা হয়ত হেডার লাইন  `observation` আমাদের আউটপুটে চাইনা .
আমরা এটা থেকে মুক্তি পেতে পারি এভাবে 

```
awk '{if (NR > 1) print $3}' volcano_observations.dat
```

আমরা  "earth" এর ভিতর সকল সংজুক্তি  নিতে পারি  তাদের অবসারভেসন কলাম দ্বারা :

```
awk '{if (index($3, "earth") != 0) print $3}' volcano_observations.dat
```

অথবা , আমরা একত্র করতে পারি   যদি প্রত্যেক বাক্য জাদের  "e" আছে  অবসারভেশন কলামে , হেডার অন্তরভুক্তি ছারা :

```
awk '{if (NR > 1 && index($3, "e") != 0) print $3}' volcano_observations.dat
```

অথবা , একই বিষয় , কিন্তু প্রিন্ট করবে পুরো সংজুক্তি :

```
awk '{if (NR > 1 && index($3, "e") != 0) print $0}' volcano_observations.dat
```

 - **প্রতিযোগিতামুলক প্রশ্ন   **:  কিভাবে সকল মাস প্রিন্ট করা যায় অ্যালার্ট  ২ অথবা বেশি দিয়ে ?
 - **সমাধান **: `awk '{if (NR > 1 && $2 >= 2) print $1}' volcano_observations.dat`


`earthquakes.dat` আছে নিচে (`cat` দ্বারা দেখ ):

```
date time magnitude lat lon depth
2011/03/01 20:21:11.11 3.1 49.12 -123.10 45
2011/03/01 21:45:51.04 3.8 49.21 -123.08 42
2011/03/01 21:53:42.33 2.5 49.01 -122.89  5
2011/03/01 21:58:32.17 3.4 48.99 -122.89  2
2011/03/01 22:03:56.10 4.3 49.03 -123.12 35
2011/03/01 23:22:45.89 3.1 49.01 -122.91  1
2011/03/02 04:17:03.77 4.3 49.02 -123.01 0.5
2011/03/02 12:01:34.32 3.7 49.17 -123.20 43
2011/03/02 15:34:56.51 2.8 49.14 -123.00 46
2011/03/03 05:21:23.09 3.4 49.09 -123.11 41
2011/03/03 08:54:56.67 3.3 49.09 -123.10 43
2011/03/03 16:32:45.52 4.1 49.10 -123.12 42
```

এই তথ্য দ্বারা , অগভীর ভুমিকম্প   আগ্নেয় কর্মসূচি নির্দেশ করতে পারে,
যেখানে গভির ভূমিকম্প উৎপত্তি হয় ভাঙ্গা অংশ থেকে । 

 - ** প্রতিযোগিতামুলক প্রশ্ন  **: কিভাবে আগ্নেয়গিরি হতে উৎপন্ন সকল ভূমিকম্প এর উপস্তিতি প্রিন্ট করা যায় ?
 - **সমাধান **: `awk '{ if (NR > 1 && $6 <= 10) print $0}' earthquakes.dat`

অথবা , শুধু ওগুলোর ব্যপকতা প্রিন্ট কর  :

```
awk '{ if (NR > 1 && $6 <= 10) print $3}' earthquakes.dat
```

অথবা , ব্যপকতা ও গভীরতা :

```
awk '{ if (NR > 1 && $6 <= 10) print $3,$6}' earthquakes.dat
```

আমরা যা পেতে চাই তার সাথে কিছু লেখা যুক্ত করতে পারি :

```
awk '{ if (NR > 1 && $6 <= 10) print "magnitude",$3,"depth",$6}' earthquakes.dat
```

আমরা এটা বের করতেও সক্ষম হব যে কোন দিনগুলো আগ্নেয় ভূমিকম্প দ্বারা আক্রান্ত । 
কিন্তু , বছর , মাস  এবং  দিন  গুলো আলাদা করতে হবে  `/`  দিয়ে   spaces এর পরিবর্তে  ,
সুতরাং , তারা হাজির হবে একটি কলামে ।  আমরা নির্দিষ্ট করতে পারি  নতুন ' ফিল্ড সেপারাটর ' দ্বারা 
 `-F` ফ্লাগ দ্বারা ; আমরা এরকম মাস পেতে পারি :

```
awk -F/ '{ if (NR > 1) print $2}' earthquakes.dat
```

কিন্তু দিন পাওয়ার জন্য আমরা যদি পরবর্তী কলাম কে  জিজ্ঞাসা করি ,
আমরা পুরো লাইনকে পাবো , তারপর  - `awk` আর থাকবেনা 
spaces এ ভেঙ্গে যাবে :

```
awk -F/ '{ if (NR > 1) print $3}' earthquakes.dat
```

আমরা অন্য  field separators নির্দিষ্ট করতে পারি :

```
awk '-F[/ :]+' '{if (NR > 1) print $1}' earthquakes.dat
```

যেটা আমাদের আগ্নেয় ভূমিকম্পের দিন পেতে সাহায্য করবে :

```
awk '-F[/ :]+' '{if (NR > 1 && $10 <= 10) print $3}' earthquakes.dat
```

এবং  ডুপ্লিকেট দূর করুন  `awk` দ্বারা :

```
awk '-F[/ :]+' '{if (NR > 1 && $10 <= 10) print $3}' earthquakes.dat | awk '!_[$0]++'
```

এটার সাথে তুলনা করুন :

```
awk '-F[/ :]+' '{if (NR > 1 && $10 <= 10) print $3}' earthquakes.dat | uniq
```

## `sed`

`sed` হল শক্তিশালী টেক্সট ম্যানিপুলাশন টুলস  ,
বেশি ব্যবহৃত হয় খোজা ও প্রস্তিস্থাপন  কাজের জন্য  । 

আমরা   `2011` এর সকল প্রতিনিধি দৃষ্টান্ত করতে পারি  `2010` এর জন্য   `earthquakes.dat` এর ভিতরে  (/g = বিশ্বব্যাপী ):

```
sed 's/2011/2010/g' earthquakes.dat > earthquakes2.dat
```

আমরা যদি একটি মাসের প্রতিনিধিত্ব করতে চাই , আমাদের আরও সতর্ক হতে হবে ;
প্রতি  `03` এর পরিবর্তন  দৃষ্টান্ত রাখতে পারে ,  করতে পারে কিছু অসংকল্পিত পরিবর্তন । 
আমরা নিশ্চিত হতে পারি  ,  যদি টেক্সট  `/03/` প্যাটার্ন  অনুসরন করে তাহলে আমরা মাস দেখতে পারি ,
কিন্তু এখন  `sed` বিব্রত হবে যে  কোন backslashes কমান্ডের ,
এবং কোন  backslashes পরিবরতিত হবে  । 
আমরা যদি টেক্সট হিসেবে গননা করতএ চাই তাহলে  আমাদের  slashes কে 'escape' করতে হবে  ,
এই `\` চিহ্ন ব্যবহার করে  :

```
sed 's/\/03\//\/04\//g' earthquakes.dat > earthquakes2.dat
```

যদিও এটা পড়তে একটু কষ্ট ,
অনেক  `sed` এর বাস্তবায়ন  অনেক চিহ্ন কে নেয় ;
উদাহরণ  হিসেবে , চেস্টা কর :

```
sed 's|/03/|/04/|g' earthquakes.dat > earthquakes2.dat
```

আমরা   original ফাইলের ভিতরে দৃষ্টান্ত নিতে পারি  :

```
sed -i 's/2011/2010/g' earthquakes2.dat
```

অথবা  Mac এ :

```
sed -i.tmp 's/2011/2010/g' earthquakes2.dat
```

অথবা :

```
sed -i '' 's/2011/2010/g' earthquakes2.dat
```

আমরা লাইন ডিলিট ও করতে পারি :

```
sed '/2011\/03\/03/d' earthquakes.dat > earthquakes2.dat
```

## `paste`

আমরা দুই লাইনের কলাম সংজুক্ত করতে পারি  `paste` কমান্ড দ্বারা :

```
paste -d" " earthquakes.dat earthquakes2.dat > alleqs.dat
```
